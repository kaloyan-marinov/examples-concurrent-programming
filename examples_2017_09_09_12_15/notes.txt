multi-processing vs. multithreading
(source: https://www.youtube.com/watch?v=oIN488Ldg9k)

	commonality

		both are ways of achieving multi-tasking

	a process

		has its own memory within address space

		constitutes an environment, within which multiple threads (of execution) can live

		has the property that all its threads of execution will share the process's address space (but each thread has its own stack memory and its own set of instructions) -- global variables defined in the program and heap memory can all be accessed by each thread

	how do process communicate with each other?

		a file on the disk

		shared memory

		message pipe

	another difference:

		an error or memory leak in one process will not hurt the execution of of another process

		this is not necessarily the case for threads

multi-threading in Python
(source: https://www.youtube.com/watch?v=PJ4t2U15ACo)

	is a little special because there is something called the Global Interpreter Lock

	the GIl prevents you from reaping the true benefits of multi-threading

	can still be used when you are

		waiting

		using IO-bound operations
	

multi-threading in Python
(source: https://www.youtube.com/watch?v=xz3KgbftMes)

	"a thread" in CS is short for "a thread of execution"

	analogy (by comparing a computer program to a bee hive)

		the main program (or thread)

			acts as the queen bee

			assigns jobs to worker bee

	each thread

		shares access to the program's global variables

		but maintains its own local variables and code blocks

	sequential programming (aka single-threading)

		the program runs in a known and stable order, i.e. one statement at a time

		this approach is simpler but often slower

	concurrent programming

		includes multi-threading

		allows programs to do multi-tasking -- but, on a computer with only one CPU, this is simply an illusion

		this is achieved by assigning ach task to a thread

		computers with multiple-core CPUs can actually run multiple instructions simultaneously

		but: Python has a feature called the Global Interpreter Lock (GIL), which limits a threaded Python program to run on only one core (allowing only one thread/task to be executed at a time; therefore, in order to give the illusion of multi-tasking, threaded Python programs must rapidly switch between threads)

	multi-threading

		threads

			are spawned by main program

			may interrupt each other

			may communicate (important) information to each other or to the main program by

				creating Events

				passing information as arguments

		pros

			more responsive UIs

			simpler program design (by separating tasks into independent thread bodies)

			threads can act independently of one another

		cons

			faux-parallelism in Python (due to the GIL) : do not benefit from any speed improvements

			can add complexities and severe debugging headaches (because of its non-deterministic nature)

		must safeguard against threads modifying sections of the same code in multiple places or in an undesired order; in programming, this is called synchronization

		a lock is a synchronization mechanism for enforcing access to a sensitive/critical areas of the program code such as:

			shared memory

			global data/variables

		thread_1
		--------
		x = 0
		x_lock = threading.Lock()
		with x_lock:
			x = x + 1 # critical section

		thread_2
		--------
		x = 0
		x_lock = threading.Lock()
		with x_lock:
			x = x - 2 # critical section